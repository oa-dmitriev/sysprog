------------------------------------------------------------------
Файловая система.
Язык: С.
Время: 2 недели.
------------------------------------------------------------------

Нужно реализовать свою файловую систему в памяти. Не пугайтесь,
это не сложно. Для старта предоставляется шаблон интерфейса с
некоторыми уже реализованными структурами, в файлах userfs.h и
userfs.c.

Файловая система называется UserFS, и очень примитивна. В ней нет
папок - все файлы лежат в "руте". Файлы можно создавать, удалять,
открывать на них дескрипторы и закрывать их. Каждый файл похож по
структуре на файловую систему FAT: это список блоков. В userfs.c
можно посмотреть структуры, которые описывают блок и файл, где
лежит их список. Блоки фиксированного размера, размер файла
ограничен.

На диске не хранится ничего - все в оперативной памяти, на куче.
Файлы можно читать/писать по дескриптору. API похоже на реальное
из libc:

int
ufs_open(const char *filename, int flags);

ssize_t
ufs_write(int fd, const char *buf, size_t size);

ssize_t
ufs_read(int fd, char *buf, size_t size);

int
ufs_close(int fd);

int
ufs_delete(const char *filename);

Прочитать описания этих функций можно в userfs.h.

Ваша основная задача - реализовать увеличение файла по мере записи
в него, и реализовать файловый дескриптор. Рассмотрим пару
примеров.

Есть код:

        int fd = ufs_open("any_file_name", UFS_CREATE);

После этой строки внутри userfs.c создается struct file с именем
"any_file_name", если его еще нет. Затем создается файловый
дескриптор struct filedesc.

        const char *data = "bla bla bla";
        ufs_write(fd, data, strlen(data));

Файл пустой, в нем нет блоков, поэтому вам нужно аллоцировать
нужное число блоков struct block. В данном случае это 1. В него
копируем данные. Ваш файл начинает выглядеть так:

        file:
        +---------------------+
        | bla bla bla|        | -> NULL.
        +---------------------+
                     ^
                  filedesc - дескриптор указывает сюда. Например,
                             в дескрипторе вы можете хранить
                             номер блока и смещение в нем.

Затем я продолжаю писать, но уже больше данных:

        char buf[1024];
        memset(buf, 0, sizeof(buf));
        ufs_write(fd, buf, sizeof(buf));

Вот что получится:

        file:
        +---------------------+    +---------------------+
        | bla bla bla 0 0 0 0 | -> | 0 0 0 0 0 0 0 0 0 0 | ->
        +---------------------+    +---------------------+

        +---------------------+
     -> | 0 0 0 0 0 0|        | -> NULL.
        +---------------------+
                     ^
                  filedesc

То есть понадобилось дозаполнить уже имеющийся блок, и создать еще
два блока. Они просто добавились в конец списка.

Тоже самое с чтениями - дескриптор читает последовательно
перепрыгивая на следующий блок, когда дочитал предыдущий.

Поскольку задача - реализация библиотеки, то программы main нет, а
значит и принимать на вход некуда. Вы можете писать тесты на С, в
отдельном файле, где будет main, и куда будет делаться include
вашего решения. Например, создается файл main.c, который делает
include "userfs.h" и в функции main делает какие-то тесты. Это все
собирается так:

        gcc userfs.c main.c

Варианты решения:

- 15 баллов: реализовать все функции из userfs.c, как описано
  выше.

- +5 баллов: реализовать режимы открытия файла: на чтение, на
  запись, на чтение-запись. Когда файл открывается, дескриптор в
  себе хранит режим. Когда зовется функция read/write, то режим
  проверяется. Вот и все. Флаги должны быть названы UFS_READ_ONLY,
  UFS_WRITE_ONLY, UFS_READ_WRITE. По умолчанию файл должен
  открываться на UFS_READ_WRITE. В случае ошибки доступа должна
  выставляться ошибка UFS_ERR_NO_PERMISSION.

- +5 баллов: реализовать resize. Появляется функция

  ufs_resize(int fd, size_t new_size)

  Она увеличивет или уменьшает размер файла. Если файл
  уменьшается, и часть файловых дескрипторов начинает указывать за
  пределы размера файла, то они сдвигаются на его новый конец.

Добавочные пункты на +5 баллов друг друга не включают. То есть
можно не делать ни одного, можно сделать первый, или второй, или
оба для +10.
